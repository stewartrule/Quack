// Generated by CoffeeScript 1.8.0
(function() {
  var Lib;

  Lib = (function() {
    var api, clone, detectType, dot, get, getCollectionValidator, getErrors, has, hasApi, hasDot, hasObject, hasPath, set, test, types, validate, validator;
    validator = (function() {
      var api, delegate, regexp;
      api = {};
      delegate = ['Function', 'Object', 'Array', 'Number', 'String', 'Boolean', 'Date', 'RegExp', 'Element', 'Null', 'Undefined', 'NaN'];
      _.each(delegate, function(type) {
        var fn;
        fn = 'is' + type;
        return api[fn] = _[fn];
      });
      regexp = {
        Email: /^.+@.+\..+$/,
        Zipcode: /^[0-9]{4}[A-Z]{2}$/,
        Hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/,
        Ip: /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
        Slug: /^[a-z0-9\-\_]+$/
      };
      api.regexp = regexp;
      _.each(regexp, function(rgxp, type) {
        var fn;
        fn = 'is' + type;
        return api[fn] = function(val) {
          return val && rgxp.test(val);
        };
      });
      api.types = delegate.concat(_.keys(regexp));
      return api;
    })();
    types = validator.types;
    hasApi = function(obj, methods) {
      return _.all(methods, function(method) {
        return _.has(obj, method) && _.isFunction(obj[method]);
      });
    };
    hasObject = function(parent, key) {
      return _.has(parent, key) && _.isObject(parent[key]);
    };
    dot = '.';
    hasDot = function(str) {
      return str && str.indexOf(dot) > -1;
    };
    get = function(parent, path) {
      var initial, key, last, _i, _len;
      if (!path) {
        return void 0;
      }
      if (hasDot(path)) {
        path = path.split(dot);
        initial = _.initial(path);
        last = _.last(path);
        for (_i = 0, _len = initial.length; _i < _len; _i++) {
          key = initial[_i];
          if (!hasObject(parent, key)) {
            return void 0;
          }
          parent = parent[key];
        }
        if (_.has(parent, last)) {
          return parent[last];
        }
        return void 0;
      }
      if (_.has(parent, path)) {
        return parent[path];
      }
      return void 0;
    };
    hasPath = function(parent, path) {
      var initial, key, last, _i, _len;
      if (!path) {
        return false;
      }
      if (hasDot(path)) {
        path = path.split(dot);
        initial = _.initial(path);
        last = _.last(path);
        for (_i = 0, _len = initial.length; _i < _len; _i++) {
          key = initial[_i];
          if (!hasObject(parent, key)) {
            return false;
          }
          parent = parent[key];
        }
        return _.has(parent, last);
      }
      return _.has(parent, path);
    };
    set = function(parent, path, val) {
      var initial, key, last, _i, _len;
      if (hasDot(path)) {
        path = path.split(dot);
        initial = _.initial(path);
        last = _.last(path);
        for (_i = 0, _len = initial.length; _i < _len; _i++) {
          key = initial[_i];
          if (hasObject(parent, key)) {
            parent = parent[key];
          } else {
            parent[key] = {};
            parent = parent[key];
          }
        }
        return parent[last] = val;
      } else {
        return parent[path] = val;
      }
    };
    has = function(parent, path, fn) {
      var nested;
      if (!hasPath(parent, path)) {
        return false;
      }
      nested = get(parent, path);
      return validator[fn](nested);
    };
    test = function(parent, path, regExp) {
      var str;
      if (!api.isString(parent, path)) {
        return false;
      }
      str = get(parent, path);
      return regExp.test(str);
    };
    clone = function(parent, src) {
      var nested;
      nested = get(parent, src);
      if (nested == null) {
        return null;
      }
      if (_.isObject(nested)) {
        return _.clone(nested);
      }
      return nested;
    };
    api = {
      get: get,
      set: set,
      test: test,
      clone: clone
    };
    _.each(types, function(type) {
      var fn;
      fn = 'is' + type;
      return api[fn] = function(parent, path) {
        return has(parent, path, fn);
      };
    });
    api.hasApi = function(parent, path, methods) {
      var obj;
      if (_.isArray(path)) {
        return hasApi(parent, path);
      }
      if (api.isObject(parent, path)) {
        obj = api.get(parent, path);
        return hasApi(obj, methods);
      }
      return false;
    };
    api.validator = validator;
    _.each(types, function(type) {
      return api[type.toUpperCase()] = type;
    });
    validate = function(obj, map) {
      if (_.isObject(map) && !_.isRegExp(map)) {
        return _.all(map, function(type, key) {
          var fn, nested;
          if (_.isObject(type)) {
            if (_.isRegExp(type)) {
              return test(obj, key, type);
            }
            nested = get(obj, key);
            if (nested != null) {
              if (_.isFunction(type)) {
                return type(nested);
              }
              return validate(nested, type);
            }
            return false;
          }
          if (!_.contains(types, type)) {
            throw new Error('Unknown validation type');
          }
          fn = 'is' + type;
          return has(obj, key, fn);
        });
      }
      return false;
    };
    detectType = function(val) {
      return _.find(types, function(type) {
        var fn;
        fn = 'is' + type;
        return validator[fn](val);
      });
    };
    getErrors = function(obj, map) {
      var errors, numErrors;
      errors = {};
      if (_.isObject(map) && !_.isRegExp(map)) {
        _.each(map, function(type, key) {
          var detected, doesNotMatch, fn, nested, pathExists, subErrors, valid;
          pathExists = hasPath(obj, key);
          nested = get(obj, key);
          detected = detectType(nested);
          doesNotMatch = [];
          if (_.isObject(type)) {
            if (_.isRegExp(type)) {
              valid = test(obj, key, type);
              if (!valid) {
                if (!api.isString(obj, key)) {
                  doesNotMatch.push('String');
                }
                doesNotMatch.push('RegExp');
                errors[key] = {
                  detected: detected,
                  doesNotMatch: doesNotMatch,
                  pathExists: pathExists
                };
              }
              return;
            }
            if (nested != null) {
              if (_.isFunction(type)) {
                valid = type(nested);
                doesNotMatch.push('callback');
                if (!valid) {
                  errors[key] = {
                    detected: detected,
                    doesNotMatch: doesNotMatch,
                    pathExists: pathExists
                  };
                }
                return;
              }
              subErrors = getErrors(nested, type);
              if (!subErrors.valid) {
                _.each(subErrors.errors, function(err, k) {
                  return errors[key + '.' + k] = err;
                });
              }
              return;
            }
            errors[key] = {
              detected: detected,
              doesNotMatch: doesNotMatch,
              pathExists: pathExists
            };
          }
          if (!_.contains(types, type)) {
            throw new Error('Unknown validation type');
          }
          fn = 'is' + type;
          valid = has(obj, key, fn);
          if (!valid) {
            return errors[key] = {
              detected: detected,
              doesNotMatch: [type],
              pathExists: pathExists
            };
          }
        });
      }
      numErrors = _.keys(errors).length;
      return {
        valid: numErrors === 0,
        errors: errors,
        numErrors: numErrors
      };
    };
    api.getErrors = function(parent, path, map) {
      var detected, errors, nested, pathExists;
      if (_.isObject(path)) {
        return getErrors(parent, path);
      }
      pathExists = hasPath(parent, path);
      nested = get(parent, path);
      if (nested) {
        return getErrors(nested, map);
      }
      detected = detectType(nested);
      errors = {};
      errors[path] = {
        detected: detected,
        doesNotMatch: ['Object'],
        pathExists: pathExists
      };
      return {
        valid: false,
        errors: errors,
        numErrors: 1
      };
    };
    api.validate = function(parent, path, map) {
      var nested;
      if (_.isObject(path)) {
        return validate(parent, path);
      }
      nested = get(parent, path);
      return nested && validate(nested, map);
    };
    getCollectionValidator = function(method, type) {
      return function(value) {
        if (_.isArray(value) || _.isObject(value)) {
          return _[method](value, function(item) {
            var fn;
            if (_.isRegExp(type)) {
              return type.test(item);
            }
            if (_.contains(types, type)) {
              fn = 'is' + type;
              return validator[fn](item);
            }
            if (_.isFunction(type)) {
              return type(item);
            }
            throw new Error('Unknown validation type to validate collections');
          });
        }
        return false;
      };
    };
    api.all = function(type) {
      return getCollectionValidator('all', type);
    };
    api.any = function(type) {
      return getCollectionValidator('any', type);
    };
    api.whitelist = function(values) {
      return api.all(function(value) {
        return _.contains(values, value);
      });
    };
    api.blacklist = function(values) {
      return api.all(function(value) {
        return !_.contains(values, value);
      });
    };
    api.range = function(min, max) {
      return api.all(function(value) {
        return value >= min && value <= max;
      });
    };
    return api;
  })();

  if (typeof define === 'function' && define.amd) {
    define(function() {
      return Lib;
    });
  } else if (typeof exports === 'object') {
    module.exports = Lib;
  } else {
    window.quack = Lib;
  }

}).call(this);
